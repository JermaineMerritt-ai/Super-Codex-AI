from flask import Flask, request, jsonify
from pathlib import Path
import json, uuid, datetime, os
from jsonschema import validate, ValidationError

app = Flask(__name__)

@app.route("/")
def root():
    return "Axiom-Flame Ceremonial API - Ready for Governance v1.1"

# Path configuration
BASE = Path(__file__).resolve().parents[2]
STORAGE = BASE / "storage"
LEDGER = STORAGE / "ledger"
REPLAYS = STORAGE / "replays"
ANNALS = STORAGE / "annals"
ARTIFACTS = BASE / "artifacts"
SCHEMAS = ARTIFACTS / "schemas"

# Ensure directories exist
for p in [LEDGER, REPLAYS, ANNALS, STORAGE, ARTIFACTS, SCHEMAS]:
    p.mkdir(parents=True, exist_ok=True)

# Utility functions
def now_iso():
    return datetime.datetime.utcnow().replace(microsecond=0).isoformat() + "Z"

def write_json(path, payload):
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(json.dumps(payload, indent=2), encoding="utf-8")

def read_json(path):
    if path.exists():
        return json.loads(path.read_text(encoding="utf-8"))
    return None

# Load validation schemas
def load_schema(schema_name):
    schema_path = SCHEMAS / f"{schema_name}.schema.json"
    return read_json(schema_path)

LEDGER_SCHEMA = load_schema('ledger-entry')
HONOR_SCHEMA = load_schema('honor')
REGISTRY_SCHEMA = load_schema('registry')
HONORS_LEDGER_SCHEMA = load_schema('honors-ledger')

def load_registry():
    """Load and return current registry"""
    return read_json(ARTIFACTS / "registry" / "registry.json")

def load_honors_ledger():
    """Load the main honors ledger"""
    return read_json(ARTIFACTS / "honors" / "honors-ledger.json")

def save_honors_ledger(ledger_data):
    """Save the honors ledger with updated metadata"""
    # Update metadata
    ledger_data['metadata'] = ledger_data.get('metadata', {})
    ledger_data['metadata']['last_updated'] = now_iso()
    ledger_data['metadata']['total_honors'] = len(ledger_data.get('entries', []))
    
    # Count seals
    seal_counts = {'temporal': 0, 'eternal': 0, 'immutable': 0, 'sacred': 0}
    for entry in ledger_data.get('entries', []):
        seal = entry.get('seal', '').lower()
        if seal in seal_counts:
            seal_counts[seal] += 1
    ledger_data['metadata']['seal_counts'] = seal_counts
    
    write_json(ARTIFACTS / "honors" / "honors-ledger.json", ledger_data)
    return ledger_data

def load_honors_ledger():
    """Load the main honors ledger"""
    ledger_path = "./artifacts/honors/honors-ledger.json"
    if os.path.exists(ledger_path):
        with open(ledger_path, 'r') as f:
            return json.load(f)
    return None

def save_honors_ledger(ledger_data):
    """Save the honors ledger with updated metadata"""
    # Update metadata
    ledger_data['metadata'] = ledger_data.get('metadata', {})
    ledger_data['metadata']['last_updated'] = datetime.utcnow().isoformat() + 'Z'
    ledger_data['metadata']['total_honors'] = len(ledger_data.get('entries', []))
    
    # Count seals
    seal_counts = {'temporal': 0, 'eternal': 0, 'immutable': 0, 'sacred': 0}
    for entry in ledger_data.get('entries', []):
        seal = entry.get('seal', '').lower()
        if seal in seal_counts:
            seal_counts[seal] += 1
    ledger_data['metadata']['seal_counts'] = seal_counts
    
    ledger_path = "./artifacts/honors/honors-ledger.json"
    with open(ledger_path, 'w') as f:
        json.dump(ledger_data, f, indent=2)
    
    return ledger_data

def validate_actor_realm_capsule(actor, realm, capsule):
    """Validate actor has permission to perform ceremony in realm with capsule"""
    registry = load_registry()
    if not registry:
        return False, "Registry not available"
    
    # Find actor
    actor_data = registry.get('actors', {}).get(actor)
    if not actor_data or not actor_data.get('active'):
        return False, f"Actor '{actor}' not found or inactive"
    
    # Find realm by ID or name
    realm_data = None
    for r in registry.get('realms', []):
        if r.get('realm_id') == realm or r.get('name') == realm:
            realm_data = r
            break
    
    if not realm_data:
        return False, f"Realm '{realm}' not found"
    
    if realm_data.get('status') not in ['Active', 'Crowned']:
        return False, f"Realm '{realm}' is not active (status: {realm_data.get('status')})"
    
    # Check if actor has access to realm
    if realm_data.get('realm_id') not in actor_data.get('realms', []):
        return False, f"Actor '{actor}' does not have access to realm '{realm}'"
    
    # Check if capsule is available in realm
    if capsule not in realm_data.get('capsules', []):
        return False, f"Capsule '{capsule}' not available in realm '{realm}'"
    
    return True, "Validation successful"

@app.route("/health", methods=["GET"])
def health():
    return jsonify({"status": "ok", "time": now_iso()})

@app.route("/reason", methods=["POST"])
def reason():
    data = request.get_json(force=True)
    dispatch_id = f"AXF-{datetime.datetime.utcnow():%Y-%m-%d}-{str(uuid.uuid4())[:8]}"
    summary = f"{data.get('intent','Reasoning')} sealed for realm {data.get('realm','Unknown')}."
    ledger_entry = {
        "ledger_version": "1.0",
        "dispatch_id": dispatch_id,
        "timestamp": now_iso(),
        "actor": data.get("actor","Custodian"),
        "realm": data.get("realm","Unspecified"),
        "capsule": data.get("capsule","General"),
        "intent": data.get("intent","Reasoning"),
        "input": data.get("input", {}),
        "output": {"summary": summary},
        "governance": {"seal": data.get("seal","Eternal"), "audit_required": True},
        "links": {}
    }
    
    # Validate against schema if available
    if LEDGER_SCHEMA:
        try:
            validate(instance=ledger_entry, schema=LEDGER_SCHEMA)
        except ValidationError as e:
            return jsonify({"error": f"Schema validation failed: {e.message}"}), 400
    
    write_json(LEDGER / f"{dispatch_id}.json", ledger_entry)
    return jsonify({"ok": True, "dispatch_id": dispatch_id, "summary": summary})

@app.route("/replay", methods=["POST"])
def replay():
    payload = request.get_json(force=True)
    ref_id = payload.get("dispatch_id")
    if not ref_id:
        return jsonify({"ok": False, "error": "dispatch_id required"}), 400

    ledger_path = LEDGER / f"{ref_id}.json"
    if not ledger_path.exists():
        return jsonify({"ok": False, "error": "ledger not found"}), 404

    ledger_entry = read_json(ledger_path)
    replay_record = {
        "replay_version": "1.0",
        "replay_id": f"RP-{str(uuid.uuid4())[:8]}",
        "timestamp": now_iso(),
        "source_dispatch_id": ref_id,
        "realm": ledger_entry["realm"],
        "capsule": ledger_entry["capsule"],
        "audit": {"status": "Verified", "notes": "Replay authorization matched Eternal Seal"}
    }
    write_json(REPLAYS / f"{replay_record['replay_id']}.json", replay_record)
    return jsonify({"ok": True, "replay": replay_record})

@app.route("/audit", methods=["POST"])
def audit():
    payload = request.get_json(force=True)
    ref = payload.get("dispatch_id")
    if not ref:
        return jsonify({"ok": False, "error": "dispatch_id required"}), 400

    path = LEDGER / f"{ref}.json"
    exists = path.exists()
    return jsonify({
        "ok": exists,
        "dispatch_id": ref,
        "audit": "Present in ledger" if exists else "Missing"
    })

# Legacy API compatibility
@app.route('/api/reasoning', methods=['POST'])
def reasoning():
    """Legacy API endpoint - redirects to /reason"""
    return reason()

@app.route('/api/replay/<dispatch_id>', methods=['GET'])
def get_replay(dispatch_id):
    """Retrieve replay data for audit"""
    replay_path = os.path.join(app.config['REPLAYS_PATH'], f"{dispatch_id}.json")
    
    if os.path.exists(replay_path):
        with open(replay_path, 'r') as f:
            return jsonify(json.load(f))
    
    return jsonify({"error": "Replay not found"}), 404

@app.route('/api/ledger', methods=['GET'])
def get_ledger():
    """Get recent ledger entries"""
    # This would typically query a database or scan files
    return jsonify({"entries": [], "message": "Ledger query endpoint"})

@app.route('/api/registry', methods=['GET'])
def get_registry():
    """Get current registry state"""
    registry_path = "./artifacts/registry/registry.json"
    
    if os.path.exists(registry_path):
        with open(registry_path, 'r') as f:
            return jsonify(json.load(f))
    
    return jsonify({"error": "Registry not found"}), 404

@app.route('/api/honors', methods=['POST'])
def create_honor():
    """Create a new honor award"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({"error": "No JSON data provided"}), 400
        
        # Validate required fields
        required_fields = ['recipient', 'achievement']
        missing_fields = [field for field in required_fields if not data.get(field)]
        if missing_fields:
            return jsonify({"error": f"Missing required fields: {', '.join(missing_fields)}"}), 400
        
        # Generate honor ID
        honor_id = f"HNR-{datetime.now().year}-{str(uuid.uuid4().int)[:3]}"
        
        honor_entry = {
            "honor_id": honor_id,
            "recipient": data['recipient'],
            "realm": data.get('realm', 'Default'),
            "achievement": data['achievement'],
            "timestamp": datetime.utcnow().isoformat() + 'Z',
            "seal": data.get('seal', 'Eternal'),
            "verification": {
                "ceremony_refs": data.get('ceremony_refs', []),
                "audit_passed": data.get('audit_passed', True),
                "witness_count": data.get('witness_count', 0)
            },
            "metadata": {
                "category": data.get('category', 'Service'),
                "tier": data.get('tier', 'Bronze')
            }
        }
        
        # Validate against schema if available
        if HONOR_SCHEMA:
            try:
                validate(instance=honor_entry, schema=HONOR_SCHEMA)
            except ValidationError as e:
                return jsonify({"error": f"Schema validation failed: {e.message}"}), 400
        
        # Save honor entry
        honors_path = Path("./artifacts/honors")
        honors_path.mkdir(parents=True, exist_ok=True)
        
        with open(honors_path / f"{honor_id}.json", 'w') as f:
            json.dump(honor_entry, f, indent=2)
        
        return jsonify(honor_entry)
        
    except Exception as e:
        return jsonify({"error": f"Internal server error: {str(e)}"}), 500

@app.route('/api/validate/ceremony', methods=['POST'])
def validate_ceremony():
    """Validate a ceremony structure against schema"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({"error": "No JSON data provided"}), 400
        
        if not LEDGER_SCHEMA:
            return jsonify({"error": "Ledger schema not available"}), 500
        
        validate(instance=data, schema=LEDGER_SCHEMA)
        return jsonify({"valid": True, "message": "Ceremony structure is valid"})
        
    except ValidationError as e:
        return jsonify({"valid": False, "error": e.message, "path": list(e.path)}), 400
    except Exception as e:
        return jsonify({"error": f"Internal server error: {str(e)}"}), 500

@app.route('/api/ceremonies', methods=['GET'])
def list_ceremonies():
    """List recent ceremonies with optional filtering"""
    try:
        # Query parameters
        actor = request.args.get('actor')
        realm = request.args.get('realm')
        limit = int(request.args.get('limit', 10))
        
        ceremonies_path = Path("./artifacts/ceremonies")
        if not ceremonies_path.exists():
            return jsonify({"ceremonies": []})
        
        ceremonies = []
        for file_path in sorted(ceremonies_path.glob("*.json"), reverse=True)[:limit]:
            with open(file_path, 'r') as f:
                ceremony = json.load(f)
                
                # Apply filters
                if actor and ceremony.get('actor') != actor:
                    continue
                if realm and ceremony.get('realm') != realm:
                    continue
                    
                ceremonies.append(ceremony)
        
        return jsonify({"ceremonies": ceremonies, "count": len(ceremonies)})
        
    except Exception as e:
        return jsonify({"error": f"Internal server error: {str(e)}"}), 500

@app.route('/api/realms', methods=['GET'])
def list_realms():
    """List all realms with optional status filtering"""
    try:
        status_filter = request.args.get('status')
        registry = load_registry()
        
        if not registry:
            return jsonify({"error": "Registry not available"}), 500
        
        realms = registry.get('realms', [])
        
        if status_filter:
            realms = [r for r in realms if r.get('status') == status_filter]
        
        return jsonify({"realms": realms, "count": len(realms)})
        
    except Exception as e:
        return jsonify({"error": f"Internal server error: {str(e)}"}), 500

@app.route('/api/realms/<realm_id>', methods=['GET'])
def get_realm(realm_id):
    """Get specific realm details"""
    try:
        registry = load_registry()
        
        if not registry:
            return jsonify({"error": "Registry not available"}), 500
        
        for realm in registry.get('realms', []):
            if realm.get('realm_id') == realm_id:
                return jsonify(realm)
        
        return jsonify({"error": f"Realm '{realm_id}' not found"}), 404
        
    except Exception as e:
        return jsonify({"error": f"Internal server error: {str(e)}"}), 500

@app.route('/api/actors/<actor_name>/permissions', methods=['GET'])
def get_actor_permissions(actor_name):
    """Get actor permissions and realm access"""
    try:
        registry = load_registry()
        
        if not registry:
            return jsonify({"error": "Registry not available"}), 500
        
        actor_data = registry.get('actors', {}).get(actor_name)
        if not actor_data:
            return jsonify({"error": f"Actor '{actor_name}' not found"}), 404
        
        # Get realm details for actor's realms
        actor_realms = []
        for realm in registry.get('realms', []):
            if realm.get('realm_id') in actor_data.get('realms', []):
                actor_realms.append({
                    "realm_id": realm.get('realm_id'),
                    "name": realm.get('name'),
                    "status": realm.get('status'),
                    "capsules": realm.get('capsules', [])
                })
        
        return jsonify({
            "actor": actor_name,
            "role": actor_data.get('role'),
            "permissions": actor_data.get('permissions', []),
            "active": actor_data.get('active'),
            "accessible_realms": actor_realms
        })
        
    except Exception as e:
        return jsonify({"error": f"Internal server error: {str(e)}"}), 500

@app.route('/api/validate/registry', methods=['POST'])
def validate_registry_data():
    """Validate registry structure against schema"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({"error": "No JSON data provided"}), 400
        
        if not REGISTRY_SCHEMA:
            return jsonify({"error": "Registry schema not available"}), 500
        
        validate(instance=data, schema=REGISTRY_SCHEMA)
        return jsonify({"valid": True, "message": "Registry structure is valid"})
        
    except ValidationError as e:
        return jsonify({"valid": False, "error": e.message, "path": list(e.path)}), 400
    except Exception as e:
        return jsonify({"error": f"Internal server error: {str(e)}"}), 500

@app.route('/api/honors-ledger', methods=['GET'])
def get_honors_ledger():
    """Get the complete honors ledger"""
    try:
        ledger = load_honors_ledger()
        if not ledger:
            return jsonify({"error": "Honors ledger not found"}), 404
        
        return jsonify(ledger)
        
    except Exception as e:
        return jsonify({"error": f"Internal server error: {str(e)}"}), 500

@app.route('/api/honors-ledger/entries', methods=['POST'])
def add_honor_to_ledger():
    """Add a new honor entry to the ledger"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({"error": "No JSON data provided"}), 400
        
        # Validate required fields
        required_fields = ['name', 'deed', 'insignia']
        missing_fields = [field for field in required_fields if not data.get(field)]
        if missing_fields:
            return jsonify({"error": f"Missing required fields: {', '.join(missing_fields)}"}), 400
        
        # Load existing ledger or create new one
        ledger = load_honors_ledger()
        if not ledger:
            ledger = {
                "honors_version": "1.0",
                "entries": [],
                "metadata": {
                    "created": datetime.utcnow().isoformat() + 'Z'
                }
            }
        
        # Generate next honor ID
        existing_ids = [int(entry['honor_id'].split('-')[1]) for entry in ledger.get('entries', [])]
        next_id = max(existing_ids) + 1 if existing_ids else 1
        honor_id = f"HK-{next_id:04d}"
        
        # Create honor entry
        honor_entry = {
            "honor_id": honor_id,
            "name": data['name'],
            "deed": data['deed'],
            "date": data.get('date', datetime.now().strftime('%Y-%m-%d')),
            "insignia": data['insignia'],
            "notes": data.get('notes', ''),
            "authority": data.get('authority', 'Council'),
            "realm": data.get('realm', ''),
            "seal": data.get('seal', 'Eternal'),
            "witnesses": data.get('witnesses', [])
        }
        
        # Validate the complete ledger structure
        ledger['entries'].append(honor_entry)
        
        if HONORS_LEDGER_SCHEMA:
            try:
                validate(instance=ledger, schema=HONORS_LEDGER_SCHEMA)
            except ValidationError as e:
                return jsonify({"error": f"Schema validation failed: {e.message}"}), 400
        
        # Save updated ledger
        updated_ledger = save_honors_ledger(ledger)
        
        return jsonify({
            "message": "Honor added successfully",
            "honor_id": honor_id,
            "entry": honor_entry,
            "ledger_stats": updated_ledger['metadata']
        })
        
    except Exception as e:
        return jsonify({"error": f"Internal server error: {str(e)}"}), 500

@app.route('/api/honors-ledger/entries/<honor_id>', methods=['GET'])
def get_honor_entry(honor_id):
    """Get a specific honor entry by ID"""
    try:
        ledger = load_honors_ledger()
        if not ledger:
            return jsonify({"error": "Honors ledger not found"}), 404
        
        for entry in ledger.get('entries', []):
            if entry.get('honor_id') == honor_id:
                return jsonify(entry)
        
        return jsonify({"error": f"Honor entry '{honor_id}' not found"}), 404
        
    except Exception as e:
        return jsonify({"error": f"Internal server error: {str(e)}"}), 500

@app.route('/api/validate/honors-ledger', methods=['POST'])
def validate_honors_ledger_data():
    """Validate honors ledger structure against schema"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({"error": "No JSON data provided"}), 400
        
        if not HONORS_LEDGER_SCHEMA:
            return jsonify({"error": "Honors ledger schema not available"}), 500
        
        validate(instance=data, schema=HONORS_LEDGER_SCHEMA)
        return jsonify({"valid": True, "message": "Honors ledger structure is valid"})
        
    except ValidationError as e:
        return jsonify({"valid": False, "error": e.message, "path": list(e.path)}), 400
    except Exception as e:
        return jsonify({"error": f"Internal server error: {str(e)}"}), 500

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=int(os.getenv("PORT", "8080")))