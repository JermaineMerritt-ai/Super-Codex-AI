{"ast":null,"code":"// src/lib/ceremony.ts\n// Helper functions for ceremony operations with error handling\n\nimport { api } from '../api';\nimport { notify } from './notify';\n/**\r\n * Execute a ceremony command with proper error handling and user feedback\r\n */\nexport async function executeCeremony(command, token, options = {}) {\n  const {\n    successMessage,\n    errorPrefix = 'Ceremony failed',\n    showSuccess = true\n  } = options;\n  try {\n    const response = await api('/axiom/execute', 'POST', command, token);\n    if (showSuccess && successMessage) {\n      notify.success(successMessage);\n    }\n    return response;\n  } catch (e) {\n    var _ref, _e$message;\n    const errorMessage = (_ref = (_e$message = e.message) !== null && _e$message !== void 0 ? _e$message : e.toString()) !== null && _ref !== void 0 ? _ref : 'Unknown error';\n    notify.error(`${errorPrefix}: ${errorMessage}`);\n    throw e; // Re-throw so caller can handle if needed\n  }\n}\n\n/**\r\n * Invoke a ceremony with standard error handling\r\n */\nexport async function invokeCeremony(payload, token) {\n  return executeCeremony({\n    command: 'invoke',\n    payload\n  }, token, {\n    successMessage: `Ceremony invoked: ${payload.capsule}`,\n    errorPrefix: 'Ceremony invocation failed'\n  });\n}\n\n/**\r\n * Perform ceremony reasoning with error handling\r\n */\nexport async function reasonCeremony(payload, token) {\n  return executeCeremony({\n    command: 'reason',\n    payload\n  }, token, {\n    successMessage: `Ceremony reasoning complete: ${payload.capsule}`,\n    errorPrefix: 'Ceremony reasoning failed'\n  });\n}\n\n/**\r\n * Audit a ceremony with error handling\r\n */\nexport async function auditCeremony(auditId, token) {\n  return executeCeremony({\n    command: 'audit',\n    payload: {\n      auditId\n    }\n  }, token, {\n    successMessage: `Audit complete: ${auditId}`,\n    errorPrefix: 'Ceremony audit failed'\n  });\n}\n\n/**\r\n * Replay a ceremony with error handling\r\n */\nexport async function replayCeremony(dispatchId, token) {\n  return executeCeremony({\n    command: 'replay',\n    payload: {\n      dispatchId\n    }\n  }, token, {\n    successMessage: `Ceremony replayed: ${dispatchId}`,\n    errorPrefix: 'Ceremony replay failed'\n  });\n}\n\n/**\r\n * Check ceremony health with error handling\r\n */\nexport async function checkCeremonyHealth(token) {\n  return executeCeremony({\n    command: 'health',\n    payload: {}\n  }, token, {\n    showSuccess: false,\n    // Don't show success for health checks\n    errorPrefix: 'Health check failed'\n  });\n}\n\n// Example usage patterns:\n/*\r\n\r\n// Basic ceremony invocation\r\ntry {\r\n  const result = await invokeCeremony({\r\n    actor: \"Custodian\",\r\n    realm: \"PL-001\",\r\n    capsule: \"Sovereign Crown\",\r\n    intent: \"Crown.Invocation\"\r\n  }, token);\r\n  \r\n  console.log('Ceremony result:', result);\r\n} catch (e) {\r\n  // Error already shown to user via notify.error\r\n  console.error('Ceremony failed:', e);\r\n}\r\n\r\n// Manual ceremony with custom error handling\r\ntry {\r\n  const result = await api('/axiom/execute', 'POST', {\r\n    command: 'invoke',\r\n    payload: {\r\n      actor: \"Custodian\", \r\n      realm: \"PL-001\", \r\n      capsule: \"Sovereign Crown\"\r\n    }\r\n  }, token);\r\n} catch (e: any) {\r\n  notify.error(`Ceremony failed: ${e.message ?? e}`);\r\n}\r\n\r\n// Using the ceremony helper\r\nawait executeCeremony(\r\n  { \r\n    command: 'invoke', \r\n    payload: { actor: \"Custodian\", realm: \"PL-001\", capsule: \"Crown\" }\r\n  },\r\n  token,\r\n  { \r\n    successMessage: \"Crown ceremony completed successfully!\",\r\n    errorPrefix: \"Crown ceremony failed\"\r\n  }\r\n);\r\n\r\n*/","map":{"version":3,"names":["api","notify","executeCeremony","command","token","options","successMessage","errorPrefix","showSuccess","response","success","e","_ref","_e$message","errorMessage","message","toString","error","invokeCeremony","payload","capsule","reasonCeremony","auditCeremony","auditId","replayCeremony","dispatchId","checkCeremonyHealth"],"sources":["C:/Users/JMerr/OneDrive/Documents/.vscode/codex_project/backend/services/dominion/Super-Codex-AI/frontend/src/lib/ceremony.ts"],"sourcesContent":["// src/lib/ceremony.ts\r\n// Helper functions for ceremony operations with error handling\r\n\r\nimport { api } from '../api';\r\nimport { notify } from './notify';\r\n\r\nexport interface CeremonyPayload {\r\n  actor: string;\r\n  realm: string;\r\n  capsule: string;\r\n  intent?: string;\r\n  [key: string]: any;\r\n}\r\n\r\nexport interface CeremonyCommand {\r\n  command: 'invoke' | 'reason' | 'audit' | 'replay' | 'health';\r\n  payload: CeremonyPayload | { [key: string]: any };\r\n}\r\n\r\n/**\r\n * Execute a ceremony command with proper error handling and user feedback\r\n */\r\nexport async function executeCeremony(\r\n  command: CeremonyCommand, \r\n  token: string,\r\n  options: { \r\n    successMessage?: string;\r\n    errorPrefix?: string;\r\n    showSuccess?: boolean;\r\n  } = {}\r\n): Promise<any> {\r\n  const { \r\n    successMessage, \r\n    errorPrefix = 'Ceremony failed',\r\n    showSuccess = true \r\n  } = options;\r\n\r\n  try {\r\n    const response = await api('/axiom/execute', 'POST', command, token);\r\n    \r\n    if (showSuccess && successMessage) {\r\n      notify.success(successMessage);\r\n    }\r\n    \r\n    return response;\r\n  } catch (e: any) {\r\n    const errorMessage = e.message ?? e.toString() ?? 'Unknown error';\r\n    notify.error(`${errorPrefix}: ${errorMessage}`);\r\n    throw e; // Re-throw so caller can handle if needed\r\n  }\r\n}\r\n\r\n/**\r\n * Invoke a ceremony with standard error handling\r\n */\r\nexport async function invokeCeremony(\r\n  payload: CeremonyPayload, \r\n  token: string\r\n): Promise<any> {\r\n  return executeCeremony(\r\n    { command: 'invoke', payload },\r\n    token,\r\n    { \r\n      successMessage: `Ceremony invoked: ${payload.capsule}`,\r\n      errorPrefix: 'Ceremony invocation failed'\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Perform ceremony reasoning with error handling\r\n */\r\nexport async function reasonCeremony(\r\n  payload: CeremonyPayload, \r\n  token: string\r\n): Promise<any> {\r\n  return executeCeremony(\r\n    { command: 'reason', payload },\r\n    token,\r\n    { \r\n      successMessage: `Ceremony reasoning complete: ${payload.capsule}`,\r\n      errorPrefix: 'Ceremony reasoning failed'\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Audit a ceremony with error handling\r\n */\r\nexport async function auditCeremony(\r\n  auditId: string, \r\n  token: string\r\n): Promise<any> {\r\n  return executeCeremony(\r\n    { command: 'audit', payload: { auditId } },\r\n    token,\r\n    { \r\n      successMessage: `Audit complete: ${auditId}`,\r\n      errorPrefix: 'Ceremony audit failed'\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Replay a ceremony with error handling\r\n */\r\nexport async function replayCeremony(\r\n  dispatchId: string, \r\n  token: string\r\n): Promise<any> {\r\n  return executeCeremony(\r\n    { command: 'replay', payload: { dispatchId } },\r\n    token,\r\n    { \r\n      successMessage: `Ceremony replayed: ${dispatchId}`,\r\n      errorPrefix: 'Ceremony replay failed'\r\n    }\r\n  );\r\n}\r\n\r\n/**\r\n * Check ceremony health with error handling\r\n */\r\nexport async function checkCeremonyHealth(token: string): Promise<any> {\r\n  return executeCeremony(\r\n    { command: 'health', payload: {} },\r\n    token,\r\n    { \r\n      showSuccess: false, // Don't show success for health checks\r\n      errorPrefix: 'Health check failed'\r\n    }\r\n  );\r\n}\r\n\r\n// Example usage patterns:\r\n/*\r\n\r\n// Basic ceremony invocation\r\ntry {\r\n  const result = await invokeCeremony({\r\n    actor: \"Custodian\",\r\n    realm: \"PL-001\",\r\n    capsule: \"Sovereign Crown\",\r\n    intent: \"Crown.Invocation\"\r\n  }, token);\r\n  \r\n  console.log('Ceremony result:', result);\r\n} catch (e) {\r\n  // Error already shown to user via notify.error\r\n  console.error('Ceremony failed:', e);\r\n}\r\n\r\n// Manual ceremony with custom error handling\r\ntry {\r\n  const result = await api('/axiom/execute', 'POST', {\r\n    command: 'invoke',\r\n    payload: {\r\n      actor: \"Custodian\", \r\n      realm: \"PL-001\", \r\n      capsule: \"Sovereign Crown\"\r\n    }\r\n  }, token);\r\n} catch (e: any) {\r\n  notify.error(`Ceremony failed: ${e.message ?? e}`);\r\n}\r\n\r\n// Using the ceremony helper\r\nawait executeCeremony(\r\n  { \r\n    command: 'invoke', \r\n    payload: { actor: \"Custodian\", realm: \"PL-001\", capsule: \"Crown\" }\r\n  },\r\n  token,\r\n  { \r\n    successMessage: \"Crown ceremony completed successfully!\",\r\n    errorPrefix: \"Crown ceremony failed\"\r\n  }\r\n);\r\n\r\n*/"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}